1.身份认证的概念
  1）身份认证是计算机及网络系统确认操作者身份的过程。身份认证是在远程通信中获得信任的手段，是安全服务中最为基本
     的内容。
  2）身份认证是最基本的安全服务，其他安全服务都依赖于它，是网络安全的基石，是整个信息安全的基础。
2.身份认证与消息认证的差别
  1）身份认证又称作身份识别、实体认证、身份证实等；
  2）实体认证与消息认证的差别在于，消息认证本身不提供时间性，而实体认证一般都是实时的；另一方面实体认证通常证实
     实体本身，而消息认证除了证实消息的合法性和完整性外，还要知道消息的含义；
3.身份认证和数字签名的联系与区别
  1）两者都是确保数据真实性的安全措施；
  2）身份认证一般是基于收发双方共享的保密数据，以证实被鉴别对象的真实性；而用于验证签名的数据是公开的；
  3）身份认证允许收发双方互相验证其真实性，数字签名则允许第三者验证；
  4）对于数字签名来说，发送方不能抵赖，接收方不能伪造，并且可由仲裁进行调解，而身份认证却不一定具备这些特点；
  5）数字签名是实现身份认证的一个途径，身份认证技术的实现可能需要使用数字签名技术；
  6）身份识别一般不是"终生"的，而数字签名则应当是长期有效的，未来仍可以启用；
4.身份认证的方式
  1）基于口令的认证方式
  2）基于智能卡的认证方式
  3）基于生物特征的认证方式
5.基于口令的认证方式
  1）口令存储的方法
     ① 直接明文存储口令
	 ② Hash散列存储口令
  2）安全性
     ① 是一种单因素的认证，它的安全性依赖于密码；
	 ② 常规的口令方案涉及不随时间变化的口令，提供所谓的弱鉴别；
  3）改进方法
    ① 尽可能地选用易记、难猜、抗分析能力强、能较好地抵抗离线字典攻击和在线字典攻击的口令；
	② 对口令的存储加密，尽可能地采用Hash散列值形式存储口令；
	③ 采用动态口令认证技术
	   a.口令表认证技术
	   b.双因子认证技术，如S/KEY认证技术
  4）基于一次性口令思想的身份认证 S/KEY 的认证过程 (RFC1760)
     a.用户向身份认证服务器提出连接请求；
	 b.服务器返回应答，并附带两个参数（seed, seq）;
	 c.用户输入 口令，系统将 口令 与 seed 连接，进行 seq 次Hash计算，产生一次性口令，传给服务器；
	 d.服务器必须存储一个文件，它存储每一个用户上次登录的一次性口令。服务器收到用户传过来的一次性口令后，再进行一
	   次Hash计算，与先前存储的口令进行比较，若匹配则通过身份认证，并用这次的口令覆盖原先的口令。下次用户登录时，
	   服务器将送出 seq' = seq - 1。这样，如果客户确实是原来的那个真实用户，那么它进行 seq - 1 次Hash计算的一次性
	   口令应该与服务器上存储的口令一致；
6.零知识证明概述
  1）零知识证明指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。
  2）零知识证明实质上是一种涉及两方或多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。
7.网络环境下的身份认证
  1）Kerberos认证系统和X.509认证服务。
  2）Kerberos认证系统是基于对称密码体制的身份认证技术，X.509认证服务是基于公钥密码体制的身份认证技术。
8.Kerberos认证系统概述
  1）Kerberos是网络通信提供可信第三方服务的面向开放系统的认证机制，起着可信仲裁的作用。
  2）每当客户C申请得到某服务程序S的服务时，用户和服务程序会首先向Kerberos要求认证对方的身份，认证建立在用户和服务
     程序对Kerberos信任的基础上。在申请认证时，客户C和服务S都可以看成是Kerberos认证系统的客户。
  3）Kerberos系统有5个版本，公开发布的版本包括v4和v5，v4和v5虽然从概念上看很相似，但根本原理完全不同。v4只能适用于
     TCP/IP协议。
  4）通常Kerberos系统采用分布式服务器体系结构，使得服务器能够进行系统间的相互备份及可扩展性。
9.Kerberos认证系统的基本原理
  1）应用服务器的基本任务是提供网络服务，如果由应用服务器提供认证功能，势必会增加每个服务器的负担。为此，通常的做法
     是引入一个（或一组）称为认证服务器（AS）的独立第三方来承担用户到服务器和服务器到用户的身份认证服务。
  2）认证服务器应该知道其管辖范围内的所有客户机的口令，因此，在Kerberos认证系统中有一个集中的中央数据库用以保存所有
     客户身份信息和他们对应的口令信息。需要认证的用户都需要向Kerberos注册其口令，口令一般都是以加密形式存储在数据库
	 中。
  3）认证服务器还必须与每一个应用服务器共享一个唯一的密钥，并假定这些密钥已经安全分发。
  4）简单的身份认证方式具体过程如下：
     ① 用户登录到客户机 C 上，请求访问服务器 S。C 首先要求用户输入口令，然后向认证服务器 AS 发送认证请求，其中包括
	    用户标识符 IDc、服务器标识符 IDs 及用户的口令 Pc；
				C -> AS: IDc||Pc||IDs
	 ② AS 搜索其中中心数据库，将收到的 Pc 和数据库存储的口令进行比较，以验证用户的身份和权限。两项都验证通过，那么
	    AS 就认为该用户是可信的。之后 AS 为客户机 C 生成一张票据 Ticket 发送给 C，票据中包含用户标识符 IDc、客户机
		C 的网络地址 ADc 以及应用服务器 S 的标识符 IDs。该票据使用 AS 与 S 之间共享的密钥 Ks 加密，从而使得其他用户
		（包括 C）或攻击者都不能篡改该票据的内容；
				AS -> C: Ticket		其中 Ticket = EKs[IDc||ADc||IDs]
	 ③ C 向服务器 S提供自身的标识符 IDc 和票据 Ticket 。服务器 S 对票据进行解密，并验证票据中的 IDc 是否与 C 提供的
	    IDc 是否匹配，如果匹配，则认为 C 可信，允许其访问 S 提供的服务；
				C -> S: IDc||Ticket
  5）存在的问题
     ① 票据获取频繁。一次认证一次输入一次票据获取，如果进行票据重用，会造成系统安全性下降。
	 ② C -> AS 的过程涉及到口令的明文传输，危险！
10.改进
  1）为了避免明文传输口令及重复获取票据的弊端，在认证过程中引入票据许可服务器 TGS，用来向已经经过 AS 认证的用户发放允
     许用户访问服务器 S 的服务中服务票据许可。
  2）此时系统中存在两种类型的票据：票据许可票据 TGS-Ticket 和服务许可票据 S-Ticket。S-Ticket 是客户访问服务器时需要提
     供的票据，TGS-Ticket 是客户为申请 S-Ticket 而向 TGS 服务器提供的票据。
  3）TGS-Ticket 由 AS 服务器处发放，S-Ticket 由 TGS 服务器处发放；
  4）TGS-Ticket 和 S-Ticket 均可保存以供反复使用；
  5）每次登录时，TGS-Ticket 只需向 AS 申请一次。只有当用户需要访问一种新网络服务时，才需要向 TGS 申请一个新的 S-Ticket。
  6）具体过程
     第一阶段：认证服务交换阶段，用户从 AS 获取 TGS-Ticket。这个阶段通常只在客户登录的每一次会话中执行一次。
	 ① 客户向 AS 请求 TGS-Ticket
			C -> AS: IDc||IDtgs
		该请求中包括了客户 C 的身份标识符 IDc 和 票据许可服务器 TGS 的标识符 IDtgs（TGS 可以有很多个）。在实际操作中，
		客户一般将其名字输入认证系统，而由注册程序发送给请求。
	 ② AS 向客户发放 TGS-Ticket
			AS -> C: EKc[TGS-Ticket]		其中 TGS-Ticket = EKtgs[IDc||ADc||IDtgs||TS1||lifetime1]
		其中的客户密钥 Kc 是根据用户口令计算出来的（一般是口令的单向散列），只有合法的客户才能进行解密。当客户 C 收到
		加密的 TGS-Ticket 后，会提示用户输入口令，产生解密密钥，恢复 TGS-TIcket。通过这种方式，避免了明文传递口令。
		TS 是一个时间戳，lifetime 是 TGS-Ticket 的生存时间，EKtgs 是 AS 与 TGS 共享的加密密钥。
	 第二阶段：票据许可服务交换阶段，用户从 TGS 服务器获取 S-Ticket。这个阶段通常只在每种服务中执行一次。
	 ③ 请求 S-Ticket
			C -> TGS: IDc||IDs||TGS-Ticket
		当用户 C 试图访问一个新的服务器时，客户 C 向 TGS 服务器发送一个申请 S-Ticket 的请求，其中包括客户的身份标识符
		IDc、期望获得服务的服务器的标识符 IDs 以及 TGS-Ticket。
	 ④ 发放 S-Ticket
			TGS -> C: S-Ticket				其中 S-Ticket = EKs[IDc||ADc||IDs||TS2||lifetime2]
		TGS 对收到的票据进行解密验证，包括检查 IDtgs 是否匹配，票据是否过期，IDc 和 网络地址 ADc 是否匹配。如果匹配，
		那么 TGS 服务器就认为 C 是经过认证的，是可信的。
		IDs 是应用服务器的标识符, EKs 为 S 与 TGS 共享的密钥。
	 第三阶段：C 与 S 之间的认证阶段，C 使用特定的 S-Ticket 从 S 获得相应的服务，这个阶段每个服务会话执行一次。
	 ⑤ 请求并获得服务器的服务
			C -> S: IDc||S-Ticket
	7）存在的问题
	   ① TGS-Ticket 和 S-Ticket 的有效期限的确定权衡；
	   ② 用户对服务器身份未作出有效认证；
11.Kerberos V4 认证思想
  1）Kerberos V4 通过引入会话密钥(Session Key)的方式来解决上面方案存在的安全缺陷。
  2）基本思路：在 C 和 S 实际通信之前，利用票据方法由 C 和 AS 先执行一个通信交换协议，这样两次交换结束时 (C-AS 和 C-S)，
     C 和 S 获得了由 AS 为它们所产生的秘密会话密钥(Session Key)，这就为相互认证提供了基础，而且也可以在通信会话中保护其
	 他服务。
  3）具体过程
     第一阶段：认证服务交换阶段，用户从 AS 获取 TGS-Ticket。这个阶段通常只在客户登录的每一次会话中执行一次。
	 ① 客户向 AS 请求 TGS-Ticket
			C -> AS: IDc||IDtgs||TS1
		时间戳 TS1 用以向 AS 表示这一请求是新鲜的消息，并验证客户的时钟是否与 AS 同步。其他参考 [改进]。
	 ② AS 向客户发放 TGS-Ticket
			AS -> C: EKc[Kc-tgs||IDtgs||TS2||lifetime2||TGS-Ticket] 
				其中 TGS-Ticket = EKtgs[IDc||ADc||IDtgs||TS2||lifetime2]
		Kc-tgs 是客户 C 与 TGS 服务器的会话密钥，此密钥对于 TGS 已知。
	 第二阶段：票据许可服务交换阶段，用户从 TGS 服务器获取 S-Ticket。这个阶段通常只在每种服务中执行一次。
	  ③ 请求 S-Ticket
			C -> TGS: IDs||TGS_Ticket||Authenticator-C	其中 Authenticator-C = EKc-tgs[IDc||ADc||TS3]
		 客户 C 已经获取了会话密钥 Kc-tgs, 所以可以对认证符 Authenticator-C 进行加密保护。认证符具有很短的生存期。
	  ④ 发放 S-Ticket
			TGS -> C: EKc-tgs[Kc-s||IDs||TS4||S-Ticket]		其中 S-Ticket = EKs[Kc-s||IDc||ADc||IDs||TS4||lifetime4]
		 Kc-s 是由 TGS 服务器发放的用于 C 与 S 共享的会话密钥, Kc-s 对 C 和 S 均未知。
	 第三阶段：C 与 S 之间的认证阶段，C 使用特定的 S-Ticket 从 S 获得相应的服务，这个阶段每个服务会话执行一次。
	  ⑤ 客户 C 向 服务器 S 证实自己的身份
			C -> S: S-Ticket||Authenticator-C	其中 Authenticator-C = EKc-tgs[IDc||ADc||TS5]
	  ⑥ 服务器 S 向客户 C 证实自己的身份
			S -> S: EKc-s[TS5+1]
12.Kerberos的缺点
  1）时间同步问题。整个Kerberos协议都严重依赖于时钟，实践证明，要求在分步式系统环境中实现良好的时钟同步，很难。
  2）对加密体制的依赖性。V4 算法依赖于 DES, 而不支持其他的加密算法。
  3）对Internet协议的依赖性。V4 需要使用 IP 协议，不支持其他协议。
  4）消息的字节顺序。由用户自己定义，未进行标准化。
  5）重放攻击问题。V4 有效期采用 8 位的字段来实现，最小时间单位为 5min，最长有效期 有效期为 2^8 × 5 = 21h。
  6）认证转发能力。不允许将一个客户的证书转发给另一个主机使用。
  7）领域间的认证效率低。
  8）二次加密造成资源浪费。
  9）会话密钥。
  10）口令攻击问题。
13.Kerberos V5
  针对 V4 的上述缺点， V5 进行了一些改进，具体包括：
  1）消除对加密体制的依赖。
  2）加密模式的改进。
  3）会话密钥的改进。
  4）通信协议的支持。理论上可以支持任何网络通信协议。
  5）明确消息的字节顺序。规定所有消息格式均采用 ASN.1 和基本编码规则 BER。
  6）票据的有效期。可以运行任意大小的有效期。
  7）提供了认证转发能力。
  8）提出了更有效的，需要更少关系的方法来解决领域间的互操作问题。
  9）提供了一种预认证机制，使口令攻击更加困难。